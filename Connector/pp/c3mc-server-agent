#!/data/Software/mydan/perl/bin/perl -I/data/Software/mydan/Connector/lib
use strict;
use warnings;

use OPENC3::PP::Exec;
use OPENC3::PP::Server;

=head1 SYNOPSIS

 $0 servername

=cut

$|++;
my $name = shift @ARGV;
my %help = (
    promesd           => 'make openc3_node_sd.yml to prometheus',
    sender            => 'sender mesg from alertmanager',
    rule              => 'get monitor rule',
    carry             => 'get monitor carry info',
    'extend-exporter' => 'extend-exporter control: mysql,redis',
    mailmon           => 'mail monitor',
    portcheckok       => 'check port',
    inherit           => 'inherit',
    cloudmon          => 'cloudmon',
);

unless( $name )
{
    map{ print "\$0 $_ # $help{$_}\n" }keys %help;
    exit;
}

if( $name eq 'promesd' )
{
    if( -f "/data/open-c3-data/promesd.off" ) {
        $0 = "agent_server_$name";
        warn ">> skip by /data/open-c3-data/promesd.off\n";
        sleep 10*365*86400;
        exit;
    }

    my $nodetemp = "/data/Software/mydan/AGENT/conf/promesd.temp";
    my $tempfile = "$nodetemp.$$";
    my $openc3_node_sd = '/data/Software/mydan/prometheus/config/openc3_node_sd.yml';

    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 1800,
        timeout => 3600,
        pipefail => 1,
    )->run(
       "c3mc-base-treemap | awk -F';' '{print \$1}'| c3mc-base-fullnodeinfo -c projectid,inip | tee $tempfile | c3mc-mon-nodesd-format --output $openc3_node_sd.temp",
       "mv $tempfile $nodetemp && mv $openc3_node_sd.temp $openc3_node_sd",
    );
}

if( $name eq 'rule' )
{
    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 60,
        timeout => 120,
    )->run(
        "c3mc-mon-rule --output /data/Software/mydan/prometheus/config/openc3_rule.yml",
        "curl -XPOST http://OPENC3_PROMETHEUS_IP:9090/-/reload 2>/dev/null",
    );
}

if( $name eq 'carry' )
{
    if( -f "/data/open-c3-data/promesd.off" ) {
        $0 = "agent_server_$name";
        warn ">> skip by /data/open-c3-data/promesd.off\n";
        sleep 10*365*86400;
        exit;
    }

    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 60,
        timeout => 120,
    )->run(
        "cat /data/Software/mydan/AGENT/conf/promesd.temp | c3mc-mon-carry --output /data/Software/mydan/AGENT/conf/openc3_carry.yml",
        "cat /data/Software/mydan/AGENT/conf/promesd.temp | awk -F';' '{print \$2}'| c3mc-mon-proxy --output /data/Software/mydan/AGENT/conf/openc3_proxy.yml",
    );
}


if( $name eq 'sender' )
{
    chdir "/data/open-c3-data/monitor-sender" or die "chdir fail: $!";
    map{ die if system "mkdir -p  $_"; }qw( zsucc zfail run );

    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 6,
        timeout => 60,
    )->run( "ls *.wait 2>/dev/null| xargs -P 5 -i{} bash -c \"c3mc-mon-sender {}\"" );
}

if( $name eq 'extend-exporter' )
{
    my @cmd;

    for my $type ( qw( mysql redis ) )
    {
        my $file = "/data/Software/mydan/AGENT/config/$type-exporter.conf";
        next unless -f $file;

        push @cmd, "cat $file | c3mc-mon-$type-exportermaker";
        push @cmd, "cat $file | c3mc-mon-$type-exporterclean";
        push @cmd, "cat $file | c3mc-mon-$type-sdformat --output /data/Software/mydan/prometheus/config/openc3_${type}_sd.yml";
    }

    unless( @cmd ) { $0 = "agent_server_$name"; sleep 10*365*86400; exit; } 

    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 300,
        timeout => 120,
    )->run( @cmd );

}

if( $name eq 'self-healing' )
{
    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 60,
        timeout => 120,
    )->run(
       "c3mc-base-db-get -t openc3_monitor_self_healing_config altername jobname name | c3mc-mon-selfhealing-curralter | c3mc-mon-selfhealing-grepeips | c3mc-mon-selfhealing-maketask",
       "c3mc-base-db-get -t openc3_monitor_self_healing_task id instance jobname --filter 'taskuuid is null' | c3mc-mon-selfhealing-runtask",
       "c3mc-base-db-get -t openc3_monitor_self_healing_task id taskuuid --filter 'taskstat<>\"success\" and taskstat<>\"fail\"' | c3mc-mon-selfhealing-updatetask",
       'c3mc-base-db-get -t openc3_monitor_self_healing_task id instance fingerprint startsAt  alertname --filter "taskstat=\"success\" and healingstat is null and healingchecktime> $(date +%s)" | c3mc-mon-selfhealing-update',
       'c3mc-base-db-get -t openc3_monitor_self_healing_task id instance fingerprint startsAt  alertname --filter "taskstat=\"success\" and healingstat is null and healingchecktime< $(date +%s)" | c3mc-mon-selfhealing-update --close',
    );
}

if( $name eq 'mailmon' )
{
    chdir "/data/glusterfs/mailmon/data" or die "chdir fail: $!";
    map{ die if system "mkdir -p  $_"; }qw( zsucc zfail run );

    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 30,
        timeout => 60,
    )->run(
        "cd ../conf && ls |xargs -i{} c3mc-mon-mailmon-syncer {}",
        "ls *.wait 2>/dev/null| xargs -P 5 -i{} bash -c \"c3mc-mon-mailmon-sender {}\"",
    );
}

if( $name eq 'portcheckok' )
{
    if( ! -f "/etc/openc3.supervisormin.on" ) {
        $0 = "agent_server_$name";
        warn ">> skip by /etc/openc3.supervisormin.on\n";
        sleep 10*365*86400;
        exit;
    }

    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 30,
        timeout => 60,
    )->run(
       "c3mc-app-port-checkok"
    );
}

if( $name eq 'inherit' )
{
    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 300,
        timeout => 600,
    )->run( "c3mc-agent-inherit");
}

if( $name eq 'cloudmon' )
{
    OPENC3::PP::Server->new(
        name => "agent_server_$name",
        interval => 300,
        timeout => 600,
    )->run( "c3mc-cloudmon-make-task && c3mc-cloudmon-make-promesd");
}
